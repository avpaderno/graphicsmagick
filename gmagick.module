<?php

/**
 * @file
 * Integration of GraphicsMagick.
 *
 * @see http://php.net/manual/en/book.gmagick.php
 * @see http://pecl.php.net/package/gmagick
 *
 * @todo Actions:
 *   - colorshift
 *   - coloroverlay
 *   - convert_image
 *   - definecanvas
 *   - image_effects_text
 *   - imagemask
 *   - overlay
 *   - roundedcorners
 *   - sharpen
 *   - image_style_quality_image_effect_info()
 *   - Module: filtersie
 *     - filtersie_generic
 *     - filtersie_sharpen
 *     - filtersie_sharpenUSM
 *   - image_progressive_image_effect_info()
 *     - image_progressive
 */

/**
 * Rotate 0, Mirror 0.
 */
define('GMAGICK_EXIF_ORIENTATION_R0_M0', 1);

/**
 * Rotate 0, Mirror vertical.
 */
define('GMAGICK_EXIF_ORIENTATION_R0_MV', 2);

/**
 * Rotate 180, Mirror 0.
 */
define('GMAGICK_EXIF_ORIENTATION_R2_M0', 3);

/**
 * Rotate 0, Mirror horizontal.
 */
define('GMAGICK_EXIF_ORIENTATION_R0_MH', 4);

/**
 * Rotate 90, Mirror vertical.
 */
define('GMAGICK_EXIF_ORIENTATION_R1_MV', 5);

/**
 * Rotate 270, Mirror 0.
 */
define('GMAGICK_EXIF_ORIENTATION_R3_M0', 6);

/**
 * Rotate 90, Mirror horizontal.
 */
define('GMAGICK_EXIF_ORIENTATION_R1_MH', 7);

/**
 * Rotate 90, Mirror 0.
 */
define('GMAGICK_EXIF_ORIENTATION_R1_M0', 8);

/**
 * Implements hook_image_toolkits().
 */
function gmagick_image_toolkits() {
  return array(
    'gmagick' => array(
      'title' => t('GraphicsMagick'),
      'available' => extension_loaded('gmagick'),
    ),
  );
}

/**
 * Implements image_TOOLKIT_get_info().
 *
 * @see image_get_info()
 */
function image_gmagick_get_info(stdClass $image) {
  $details = FALSE;
  $data = @getimagesize($image->source);

  if (isset($data) && is_array($data)) {
    $extensions = array(
      '1' => 'gif',
      '2' => 'jpg',
      '3' => 'png',
    );

    $details = array(
      'width'     => $data[0],
      'height'    => $data[1],
      'extension' => isset($extensions[$data[2]]) ? $extensions[$data[2]] : '',
      'mime_type' => $data['mime'],
    );
  }

  return $details;
}

/**
 * Implements image_TOOLKIT_load().
 *
 * Helper function to create an image resource from a file.
 *
 * @param object $image
 *   An image object. The $image->handler value will populated by this call.
 *
 * @return bool
 *   TRUE or FALSE, based on success.
 *
 * @see image_load()
 */
function image_gmagick_load(stdClass $image) {
  try {
    $image->handler = new Gmagick(drupal_realpath($image->source));
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_save().
 *
 * Helper to write an image resource to a destination file.
 *
 * @param object $image
 *   An image object.
 * @param string $destination
 *   A string file URI or path where the image should be saved.
 *
 * @return bool
 *   TRUE or FALSE, based on success.
 *
 * @see image_save()
 */
function image_gmagick_save(stdClass $image, $destination) {
  try {
    $image->handler->write(drupal_realpath($destination));
    $image->handler->destroy();
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_resize().
 *
 * Scale an image to the specified size using GraphicsMagick.
 *
 * @param object $image
 *   An image object. The $image->info['width'] and $image->info['height']
 *   values will be modified by this call.
 * @param int $width
 *   The new width of the resized image, in pixels.
 * @param int $height
 *   The new height of the resized image, in pixels.
 * @param array $options
 *   Non standard options.
 *
 * @return bool
 *   TRUE or FALSE, based on success.
 *
 * @see image_resize()
 */
function image_gmagick_resize(stdClass $image, $width, $height, array $options = array()) {
  $options += array(
    'filter' => Gmagick::FILTER_LANCZOS,
    'blur' => 0,
    'fit' => FALSE,
  );

  try {
    $image->handler->resizeImage($width, $height, $options['filter'], $options['blur'], $options['fit']);
    _gmagick_update_image_info($image);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_rotate().
 *
 * Rotate an image the given number of degrees.
 *
 * @param object $image
 *   An image object. $image->info['width'] and $image->info['height'] values
 *   will be modified by this call.
 * @param float $degrees
 *   The number of (clockwise) degrees to rotate the image.
 * @param string $background
 *   An hexadecimal integer specifying the background color to use for the
 *   uncovered area of the image after the rotation. E.g. 0x000000 for black,
 *   0xff00ff for magenta, and 0xffffff for white. For images that support
 *   transparency, this will default to transparent. Otherwise it will
 *   be white.
 *
 * @return bool
 *   TRUE or FALSE, based on success.
 *
 * @see image_rotate()
 */
function image_gmagick_rotate(stdClass $image, $degrees, $background = NULL) {
  try {
    $image->handler->rotateImage('#' . base_convert($background, 10, 16), $degrees);
    _gmagick_update_image_info($image);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_crop().
 *
 * Crop an image using the GraphicsMagick toolkit.
 *
 * @param object $image
 *   An image object. The image->info['width'] and $image->info['height'] values
 *   will be modified by this call.
 * @param int $x
 *   The starting x offset at which to start the crop, in pixels.
 * @param int $y
 *   The starting y offset at which to start the crop, in pixels.
 * @param int $width
 *   The width of the cropped area, in pixels.
 * @param int $height
 *   The height of the cropped area, in pixels.
 *
 * @return bool
 *   TRUE or FALSE, based on success.
 *
 * @see image_crop()
 */
function image_gmagick_crop(stdClass $image, $x, $y, $width, $height) {
  try {
    $image->handler->cropImage($width, $height, $x, $y);
    _gmagick_update_image_info($image);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_desaturate().
 *
 * Convert an image resource to gray scale.
 *
 * @todo Check this statement is true for GM as well?
 * Note that transparent GIFs loose transparency when desaturated.
 *
 * @param object $image
 *   An image object.
 *
 * @return bool
 *   TRUE or FALSE, based on success.
 *
 * @see image_desaturate()
 */
function image_gmagick_desaturate(stdClass $image) {
  try {
    $image->handler->setImageColorspace(Gmagick::COLORSPACE_GRAY);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_brightness().
 *
 * @see coloractions_brightness_form()
 * @see coloractions_brightness_image()
 */
function image_gmagick_brightness(stdClass $image, $settings = array()) {
  if (isset($settings['filter_arg1']) && !isset($settings['brightness'])) {
    $settings['brightness'] = $settings['filter_arg1'];
  }

  if (isset($settings['brightness'])) {
    $settings['brightness'] = 100 + gmagick_value_to_percent($settings['brightness']);
  }

  return image_gmagick_modulate($image, $settings);
}

/**
 * Implements image_TOOLKIT_strip().
 *
 * @see imagemagick_advanced_strip_effect()
 */
function image_gmagick_strip(stdClass $image) {
  try {
    $image->handler->stripImage();
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_blur().
 *
 * @see gmagick_effects_image_effect_blur_effect()
 * @see http://php.net/manual/en/gmagick.blurimage.php
 */
function image_gmagick_blur(stdClass $image, array $options = array()) {
  $options += array(
    'channel' => array(),
  );

  uasort($options['channel'], 'drupal_sort_weight');
  //$channels = gmagick_channels();
  try {
    // @todo Figure out what the channel is for.
    // For some reason to blur a specific channel is not works.
    // The documentation says there is a third parameter, but it is better to
    // not to set.
    foreach ($options['channel'] as $channel_name => $params) {
      if ($channel_name !== 'all') {
        continue;
      }

      if (!empty($params['sigma'])) {
        // $image->handler->blurImage($params['radius'], $params['sigma'], $channels[$channel_name]['value']);
        $image->handler->blurImage($params['radius'], $params['sigma']);
      }
    }
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_colorshift().
 *
 * @see coloractions_colorshift_image()
 */
function image_gmagick_colorshift(stdClass $image, array $data = array()) {
  try {
    $image->handler->charcoalimage(1, 3);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_emboss().
 */
function image_gmagick_emboss(stdClass $image, array $options = array()) {
  $options += array(
    'radius' => 0,
    'sigma' => 0,
  );

  try {
    if ($options['sigma']) {
      $image->handler->embossImage($options['radius'], $options['sigma']);
    }
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_flip().
 */
function image_gmagick_flip(stdClass $image) {
  try {
    $image->handler->flipImage();
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_flop().
 */
function image_gmagick_flop(stdClass $image) {
  try {
    $image->handler->flopImage();
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_gamma().
 */
function image_gmagick_gamma(stdClass $image, array $options = array()) {
  $options += array(
    'gamma' => 1,
  );

  try {
    $image->handler->gammaImage($options['gamma']);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_charcoal().
 */
function image_gmagick_charcoal(stdClass $image, array $options = array()) {
  $options += array(
    'radius' => 0,
    'sigma' => 0,
  );

  try {
    $image->handler->charcoalImage($options['radius'], $options['sigma']);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_imagecache_autorotate().
 */
function image_gmagick_imagecache_autorotate(stdClass $image) {
  if (!function_exists('exif_read_data')) {
    watchdog(
      'image',
      'Image %file could not be auto-rotated: !message',
      array(
        '%file' => $image->source,
        '!message' => t('The exif_read_data() function is not available in this PHP installation. You probably have to enable the exif extension.'),
      )
    );

    return FALSE;
  }

  $exif = exif_read_data(drupal_realpath($image->source));
  if (!isset($exif['Orientation'])) {
    return TRUE;
  }

  $rotate = gmagick_exif_orientation_rotate($exif['Orientation']);
  $mirror = gmagick_exif_orientation_mirror($exif['Orientation']);

  $return = $rotate ? image_gmagick_rotate($image, $rotate) : TRUE;
  if ($return) {
    if ($rotate === 90 || $rotate === 270) {
      _gmagick_update_image_info($image);
    }

    if ($mirror === 'flip') {
      $return = image_gmagick_flip($image);
    }
    elseif ($mirror === 'flop') {
      $return = image_gmagick_flop($image);
    }
  }

  return $return;
}

/**
 * Implements image_TOOLKIT_oilpaint().
 */
function image_gmagick_oil_paint(stdClass $image, array $options = array()) {
  $options += array(
    'radius' => 0,
  );

  try {
    $image->handler->oilPaintImage($options['radius']);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_posterize().
 */
function image_gmagick_posterize(stdClass $image, $colors) {
  return image_gmagick_quantize($image, array('num_of_colors' => (int) $colors));
}

/**
 * Implements image_TOOLKIT_quantize().
 *
 * @see http://php.net/manual/en/gmagick.quantizeimage.php
 */
function image_gmagick_quantize(stdClass $image, array $options = array()) {
  $options += array(
    'num_of_colors' => 0,
    'color_space' => $image->handler->getImageColorSpace(),
    'tree_depth' => 0,
    'dither' => FALSE,
    'measure_error' => FALSE,
  );

  $color_space = gmagick_color_space_load($options['color_space']);
  if (!$color_space || $color_space['value'] == Gmagick::COLORSPACE_UNDEFINED) {
    return FALSE;
  }

  try {
    $image->handler->quantizeImage(
      $options['num_of_colors'],
      $options['color_space'],
      $options['tree_depth'],
      $options['dither'],
      $options['measure_error']
    );
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_inverse().
 */
function image_gmagick_inverse(stdClass $image) {
  return image_gmagick_solarize($image);
}

/**
 * Implements image_TOOLKIT_solarize().
 *
 * @see http://php.net/manual/en/gmagick.solarizeimage.php
 */
function image_gmagick_solarize(stdClass $image, array $options = array()) {
  $options += array(
    'threshold' => 0,
  );

  try {
    $image->handler->solarizeImage($options['threshold']);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_swirl().
 */
function image_gmagick_swirl(stdClass $image, array $options = array()) {
  $options += array(
    'degrees' => 0,
  );

  try {
    $image->handler->swirlImage($options['degrees']);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements image_TOOLKIT_brightness().
 */
function image_gmagick_modulate(stdClass $image, $settings = array()) {
  $settings += array(
    'brightness' => 100,
    'saturation' => 100,
    'hue' => 100,
  );

  try {
    $image->handler->modulateImage($settings['brightness'], $settings['saturation'], $settings['hue']);
  }
  catch (Exception $e) {
    return FALSE;
  }

  return TRUE;
}

function gmagick_channels() {
  $rgb = t('RGB', array(), array('context' => 'color channels'));
  $cmyk = t('CMYK', array(), array('context' => 'color channels'));
  $other = t('Other');

  return array(
    'red' => array(
      'group' => $rgb,
      'label' => t('Red'),
      'name' => 'red',
      'value' => Gmagick::CHANNEL_RED,
    ),
    'green' => array(
      'group' => $rgb,
      'label' => t('Green'),
      'name' => 'green',
      'value' => Gmagick::CHANNEL_GREEN,
    ),
    'blue' => array(
      'group' => $rgb,
      'label' => t('Blue'),
      'name' => 'blue',
      'value' => Gmagick::CHANNEL_BLUE,
    ),
    'cyan' => array(
      'group' => $cmyk,
      'label' => t('Cyan'),
      'name' => 'cyan',
      'value' => Gmagick::CHANNEL_CYAN,
    ),
    'magenta' => array(
      'group' => $cmyk,
      'label' => t('Magenta'),
      'name' => 'magenta',
      'value' => Gmagick::CHANNEL_MAGENTA,
    ),
    'yellow' => array(
      'group' => $cmyk,
      'label' => t('Yellow'),
      'name' => 'yellow',
      'value' => Gmagick::CHANNEL_YELLOW,
    ),
    'black' => array(
      'group' => $cmyk,
      'label' => t('Black'),
      'name' => 'black',
      'value' => Gmagick::CHANNEL_BLACK,
    ),
    'undefined' => array(
      'group' => $other,
      'label' => t('Undefined'),
      'name' => 'undefined',
      'value' => Gmagick::CHANNEL_UNDEFINED,
    ),
    'all' => array(
      'group' => $other,
      'label' => t('All'),
      'name' => 'all',
      'value' => Gmagick::CHANNEL_ALL,
    ),
    'opacity' => array(
      'group' => $other,
      'label' => t('Opacity'),
      'name' => 'opacity',
      'value' => Gmagick::CHANNEL_OPACITY,
    ),
    'matte' => array(
      'group' => $other,
      'label' => t('Matte'),
      'name' => 'matte',
      'value' => Gmagick::CHANNEL_MATTE,
    ),
    'index' => array(
      'group' => $other,
      'label' => t('Index'),
      'name' => 'index',
      'value' => Gmagick::CHANNEL_INDEX,
    ),
  );
}

function gmagick_channel_options($group = FALSE) {
  $options = array();

  foreach (gmagick_channels() as $channel) {
    if ($group) {
      $options[$channel['group']][$channel['name']] = $channel['label'];
    }
    else {
      $options[$channel['name']] = $channel['label'];
    }
  }

  return $options;
}

/**
 * @param string $key
 *
 * @return array
 */
function gmagick_color_spaces($key = 'name') {
  $color_spaces = array(
    'undefined' => array(
      'name' => 'undefined',
      'value' => Gmagick::COLORSPACE_UNDEFINED,
      'label' => t('undefined'),
    ),
    'rgb' => array(
      'name' => 'rgb',
      'value' => Gmagick::COLORSPACE_RGB,
      'label' => t('RGB'),
    ),
    'gray' => array(
      'name' => 'gray',
      'value' => Gmagick::COLORSPACE_GRAY,
      'label' => t('Gray'),
    ),
    'transparent' => array(
      'name' => 'transparent',
      'value' => Gmagick::COLORSPACE_TRANSPARENT,
      'label' => t('Transparent'),
    ),
    'ohta' => array(
      'name' => 'ohta',
      'value' => Gmagick::COLORSPACE_OHTA,
      'label' => t('OHTA'),
    ),
    'lab' => array(
      'name' => 'lab',
      'value' => Gmagick::COLORSPACE_LAB,
      'label' => t('LAB'),
    ),
    'xyz' => array(
      'name' => 'xyz',
      'value' => Gmagick::COLORSPACE_XYZ,
      'label' => t('XYZ'),
    ),
    'ycbcr' => array(
      'name' => 'ycbcr',
      'value' => Gmagick::COLORSPACE_YCBCR,
      'label' => t('YCBCR'),
    ),
    'ycc' => array(
      'name' => 'ycc',
      'value' => Gmagick::COLORSPACE_YCC,
      'label' => t('YCC'),
    ),
    'yiq' => array(
      'name' => 'yiq',
      'value' => Gmagick::COLORSPACE_YIQ,
      'label' => t('YIQ'),
    ),
    'ypbpr' => array(
      'name' => 'ypbpr',
      'value' => Gmagick::COLORSPACE_YPBPR,
      'label' => t('YPBPR'),
    ),
    'yuv' => array(
      'name' => 'yuv',
      'value' => Gmagick::COLORSPACE_YUV,
      'label' => t('YUV'),
    ),
    'cmyk' => array(
      'name' => 'cmyk',
      'value' => Gmagick::COLORSPACE_CMYK,
      'label' => t('CMYK'),
    ),
    'srgb' => array(
      'name' => 'srgb',
      'value' => Gmagick::COLORSPACE_SRGB,
      'label' => t('SRGB'),
    ),
    'hsl' => array(
      'name' => 'hsl',
      'value' => Gmagick::COLORSPACE_HSL,
      'label' => t('HSL'),
    ),
    'hwb' => array(
      'name' => 'hwb',
      'value' => Gmagick::COLORSPACE_HWB,
      'label' => t('HWB'),
    ),
  );

  if ($key === 'name') {
    return $color_spaces;
  }

  $return = array();
  foreach ($color_spaces as $color_space) {
    $return[$color_space[$key]] = $color_space;
  }

  return $return;
}

/**
 * @param string|int $id
 *
 * @return array|null
 */
function gmagick_color_space_load($id) {
  $color_spaces = gmagick_color_spaces((is_numeric($id) ? 'value' : 'name'));

  return isset($color_spaces[$id]) ? $color_spaces[$id] : NULL;
}

/**
 * @param string $key
 * @param string $value
 *
 * @return array
 */
function gmagick_color_space_options($key = 'name', $value = 'label') {
  $options = array();

  foreach (gmagick_color_spaces() as $color_space) {
    $options[$color_space[$key]] = $color_space[$value];
  }

  return $options;
}

/**
 * @param int $orientation
 *
 * @return int
 */
function gmagick_exif_orientation_rotate($orientation) {
  switch ($orientation) {
    case GMAGICK_EXIF_ORIENTATION_R1_M0:
    case GMAGICK_EXIF_ORIENTATION_R1_MH:
    case GMAGICK_EXIF_ORIENTATION_R1_MV:
      return 90;

    case GMAGICK_EXIF_ORIENTATION_R2_M0:
      return 180;

    case GMAGICK_EXIF_ORIENTATION_R3_M0:
      return 270;
  }

  return 0;
}

/**
 * @param int $orientation
 *
 * @return bool|string
 */
function gmagick_exif_orientation_mirror($orientation) {
  switch ($orientation) {
    case GMAGICK_EXIF_ORIENTATION_R0_MH:
    case GMAGICK_EXIF_ORIENTATION_R1_MH:
      return 'flip';

    case GMAGICK_EXIF_ORIENTATION_R0_MV:
    case GMAGICK_EXIF_ORIENTATION_R1_MV:
      return 'flop';
  }

  return FALSE;
}

/**
 * @param float $value
 * @param float $range
 * @param float $zero
 *
 * @return float
 */
function gmagick_value_to_percent($value, $range = 255, $zero = 0) {
  return ($value - $zero) / ($range / 100);
}

/**
 * @param object $image
 */
function _gmagick_update_image_info($image) {
  $image->info['width'] = $image->handler->getImageWidth();
  $image->info['height'] = $image->handler->getImageHeight();
}
